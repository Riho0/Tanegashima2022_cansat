 #FM用

#挿入ライブラリ
import time
from smbus import SMBus
import math
import datetime
import pigpio
import RPi.GPIO as GPIO  
from pyproj import Proj
import serial
import numpy as np
from micropyGPS import MicropyGPS
from geopy.distance import geodesic
import csv
import cgsensor
import cv2

#初期設定==============
pi=pigpio.pi()#gpio設定
i2c = SMBus(1)#i2c設定

# Set the GPIO mode
GPIO.setmode(GPIO.BCM)

# Set the GPIO pin for the servo motor
servo_R_pin = 22
servo_L_pin = 23
GPIO.setup(servo_R_pin, GPIO.OUT)
GPIO.setup(servo_L_pin, GPIO.OUT)


# Create a PWM object for the servo motor
pwm_R = GPIO.PWM(servo_R_pin, 50) # 50 Hz frequency
pwm_L = GPIO.PWM(servo_L_pin, 50)
pwm_R.start(0) # Start with 0% duty cycle (stopped)
pwm_L.start(0)

def straight(speed):
    # Convert angle to a duty cycle in the range [2.5, 12.5]
    duty_cycle_R = 2.5 + (speed + 82) / 180 * 10
    duty_cycle_L = 2.5 + (-speed + 82) / 180 * 10
    pwm_R.ChangeDutyCycle(duty_cycle_R)
    pwm_L.ChangeDutyCycle(duty_cycle_L)

def turn(speed):
    # Convert angle to a duty cycle in the range [2.5, 12.5]
    duty_cycle = 2.5 + (speed + 82) / 180 * 10
    pwm_R.ChangeDutyCycle(duty_cycle)
    pwm_L.ChangeDutyCycle(duty_cycle)

def PID2(pos_theta,sat_theta,dis0):   
    pre_turn = pos_theta-sat_theta#機体の旋回する角度
    r = 105#機体の横の長さ/2
    r_1 = 67.5#車輪の半径
    turn = r/r_1*pre_turn
    d_s = 0.05#後で直す
    seconds = dis0*d_s

    turn(45)
    time.sleep(3)
    straight(90)
    time.sleep( seconds )
    pwm_R.stop()
    pwm_L.stop()
    GPIO.cleanup()

#画像を縦に四分割して左から何番目の部分が一番赤色の部分が多いか判定する関数
def find_red_quadrant(image):
    #画像の高さと幅をタプルで返す
    height, width = image.shape[:2]
    quarter_width = width // 4

    # 画像をHSV形式に変換
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

    # HSV形式での赤色範囲を定義
    lower_red, upper_red = np.array([0, 50, 50]), np.array([10, 255, 255])

    # HSV画像から赤色のみを抽出するための閾値設定
    red_mask = cv2.inRange(hsv, lower_red, upper_red)

    # 赤のマスクを縦に4分割
    red_mask_1 = red_mask[ :, 0: quarter_width]
    red_mask_2 = red_mask[ :, quarter_width: 2 * quarter_width]
    red_mask_3 = red_mask[ :, 2 * quarter_width: 3 * quarter_width]
    red_mask_4 = red_mask[ :, 3 * quarter_width:]

    # 画像の各部に含まれる赤の割合
    red_percentage = np.sum(red_mask) / (height * width)
    red_percentage_1 = np.sum(red_mask_1) / (height * quarter_width)
    red_percentage_2 = np.sum(red_mask_2) / (height * quarter_width)
    red_percentage_3 = np.sum(red_mask_3) / (height * quarter_width)
    red_percentage_4 = np.sum(red_mask_4) / (height * quarter_width)

    # 最も赤い部分を探す、赤い部分が十分多ければ0を返す、赤い部分が無ければ5を返す
    if red_percentage > 50:
        quadrant = 0
    elif red_percentage_1 == red_percentage_2 == red_percentage_3 == red_percentage_4:
        quadrant = 5
    else:
        red_percentages = [red_percentage_1, red_percentage_2, red_percentage_3, red_percentage_4]
        quadrant = red_percentages.index(max(red_percentages)) + 1
    print(quadrant)
    return quadrant

def image_run():
    camera = cv2.VideoCapture(0)
    while True:
		# Get the current frame
        ret, image = camera.read()
		# Break if the image is not obtained
        if not ret:
            break
        # Get the current timestamp
        timestamp = time.strftime("%Y%m%d%H%M%S", time.gmtime())
        # Show the frameエラー吐くので一時コメントアウト
        #cv2.imshow("Image", image)
        # Save the frame
        cv2.imwrite(timestamp + ".jpg", image)
        print("photo ok")

        image_num = find_red_quadrant(image)
        if image_num == 0: 
            print("all mission finished!!!")
        elif image_num == 1:
            #左に強く旋回、具体的値を実験で決定
            turn(90)
            time.sleep(1)
            straight(45)
            time.sleep(2)
        elif image_num == 2:
            #左に弱く旋回、具体的値を実験で決定
            turn(45)
            time.sleep(1)
            straight(45)
            time.sleep(2)
        elif image_num == 3:
            #右に弱く旋回、具体的値を実験で決定
            turn(-45)
            time.sleep(1)
            straight(45)
            time.sleep(2)
        elif image_num == 4:
            #右に強く旋回、具体的値を実験で決定
            turn(-90)
            time.sleep(1)
            straight(45)
            time.sleep(2)
        else:
            #左に強く旋回、具体的値を実験で決定
            turn(90)
            time.sleep(2)
    
    pwm_R.stop()
    pwm_L.stop()
    GPIO.cleanup()
    time.sleep(5)
    camera.release()
    #cv2.destroyAllWindows()


 #以下，誘導
if __name__ == '__main__':

    print("GPS PROCESS FINISH!")
    image_run()
    print("ALL PROCESS FINISH")
